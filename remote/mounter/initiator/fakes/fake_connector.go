// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/IBM/ubiquity/remote/mounter/initiator"
	"github.com/IBM/ubiquity/resources"
)

type FakeConnector struct {
	ConnectVolumeStub        func(*resources.VolumeMountProperties) error
	connectVolumeMutex       sync.RWMutex
	connectVolumeArgsForCall []struct {
		arg1 *resources.VolumeMountProperties
	}
	connectVolumeReturns struct {
		result1 error
	}
	connectVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	DisconnectVolumeStub        func(*resources.VolumeMountProperties) error
	disconnectVolumeMutex       sync.RWMutex
	disconnectVolumeArgsForCall []struct {
		arg1 *resources.VolumeMountProperties
	}
	disconnectVolumeReturns struct {
		result1 error
	}
	disconnectVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConnector) ConnectVolume(arg1 *resources.VolumeMountProperties) error {
	fake.connectVolumeMutex.Lock()
	ret, specificReturn := fake.connectVolumeReturnsOnCall[len(fake.connectVolumeArgsForCall)]
	fake.connectVolumeArgsForCall = append(fake.connectVolumeArgsForCall, struct {
		arg1 *resources.VolumeMountProperties
	}{arg1})
	fake.recordInvocation("ConnectVolume", []interface{}{arg1})
	fake.connectVolumeMutex.Unlock()
	if fake.ConnectVolumeStub != nil {
		return fake.ConnectVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.connectVolumeReturns
	return fakeReturns.result1
}

func (fake *FakeConnector) ConnectVolumeCallCount() int {
	fake.connectVolumeMutex.RLock()
	defer fake.connectVolumeMutex.RUnlock()
	return len(fake.connectVolumeArgsForCall)
}

func (fake *FakeConnector) ConnectVolumeCalls(stub func(*resources.VolumeMountProperties) error) {
	fake.connectVolumeMutex.Lock()
	defer fake.connectVolumeMutex.Unlock()
	fake.ConnectVolumeStub = stub
}

func (fake *FakeConnector) ConnectVolumeArgsForCall(i int) *resources.VolumeMountProperties {
	fake.connectVolumeMutex.RLock()
	defer fake.connectVolumeMutex.RUnlock()
	argsForCall := fake.connectVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnector) ConnectVolumeReturns(result1 error) {
	fake.connectVolumeMutex.Lock()
	defer fake.connectVolumeMutex.Unlock()
	fake.ConnectVolumeStub = nil
	fake.connectVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnector) ConnectVolumeReturnsOnCall(i int, result1 error) {
	fake.connectVolumeMutex.Lock()
	defer fake.connectVolumeMutex.Unlock()
	fake.ConnectVolumeStub = nil
	if fake.connectVolumeReturnsOnCall == nil {
		fake.connectVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.connectVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnector) DisconnectVolume(arg1 *resources.VolumeMountProperties) error {
	fake.disconnectVolumeMutex.Lock()
	ret, specificReturn := fake.disconnectVolumeReturnsOnCall[len(fake.disconnectVolumeArgsForCall)]
	fake.disconnectVolumeArgsForCall = append(fake.disconnectVolumeArgsForCall, struct {
		arg1 *resources.VolumeMountProperties
	}{arg1})
	fake.recordInvocation("DisconnectVolume", []interface{}{arg1})
	fake.disconnectVolumeMutex.Unlock()
	if fake.DisconnectVolumeStub != nil {
		return fake.DisconnectVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.disconnectVolumeReturns
	return fakeReturns.result1
}

func (fake *FakeConnector) DisconnectVolumeCallCount() int {
	fake.disconnectVolumeMutex.RLock()
	defer fake.disconnectVolumeMutex.RUnlock()
	return len(fake.disconnectVolumeArgsForCall)
}

func (fake *FakeConnector) DisconnectVolumeCalls(stub func(*resources.VolumeMountProperties) error) {
	fake.disconnectVolumeMutex.Lock()
	defer fake.disconnectVolumeMutex.Unlock()
	fake.DisconnectVolumeStub = stub
}

func (fake *FakeConnector) DisconnectVolumeArgsForCall(i int) *resources.VolumeMountProperties {
	fake.disconnectVolumeMutex.RLock()
	defer fake.disconnectVolumeMutex.RUnlock()
	argsForCall := fake.disconnectVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConnector) DisconnectVolumeReturns(result1 error) {
	fake.disconnectVolumeMutex.Lock()
	defer fake.disconnectVolumeMutex.Unlock()
	fake.DisconnectVolumeStub = nil
	fake.disconnectVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnector) DisconnectVolumeReturnsOnCall(i int, result1 error) {
	fake.disconnectVolumeMutex.Lock()
	defer fake.disconnectVolumeMutex.Unlock()
	fake.DisconnectVolumeStub = nil
	if fake.disconnectVolumeReturnsOnCall == nil {
		fake.disconnectVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disconnectVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConnector) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.connectVolumeMutex.RLock()
	defer fake.connectVolumeMutex.RUnlock()
	fake.disconnectVolumeMutex.RLock()
	defer fake.disconnectVolumeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConnector) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ initiator.Connector = new(FakeConnector)
